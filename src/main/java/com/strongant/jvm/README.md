1. 那些对象可以作为GC Roots？

虚拟机栈（栈帧中的本地变量表）中的引用的对象
方法区中的类静态属性引用的对象
方法区中的常量引用的对象
本地方法栈中JNI（Native方法）的引用对象

2. 有哪些垃圾回收算法？

引用计数：一个对象被引用计数器加一，取消引用计数器减一，引用计数器为0才能被回收。优点：简单。缺点：不能解决循环引用的问题，比如A引用B，B引用A，但是这两个对象没有被其他任何对象引用，属于垃圾对象，却不能回收；每次引用都会附件一个加减法，影响性能。
标记清除法：分为两个阶段：标记阶段和清除阶段。标记阶段通过根节点标记所有可达对象，清除阶段清除所有不可达对象。缺点：因为清除不可达对象之后剩余的内存不连续，会产生大量内存碎片，不利于大对象的分配。
复制算法：将内存空间分成相同的两块，每次只是用其中的一块，垃圾回收时，将正在使用的内存中的存活对象复制到另外一块空间，然后清除正在使用的内存空间中的所有对象，这种回收算法适用于新生代垃圾回收。优点：垃圾回收对象比较多时需要复制的对象恨少，性能较好；不会存在内存碎片。缺点：将系统内存折半。
标记压缩算法：是一种老年代回收算法，在标记清除的基础上做了一些优化，首先从根节点开始标记所有不可达的对象，然后将所有可达的对象移动到内存的一端，最后清除所有不可达的对象。优点：不用将内存分为两块；不会产生内存碎片。
分代算法：新生代使用复制算法，老生带使用标记清除算法或者标记压缩算法。几乎所有的垃圾回收期都区分新生代和老生带。
分区算法：将整个堆空间分成很多个连续的不同的小空间，每个小空间独立使用，独立回收。为了更好的控制gc停顿时间，可以根据目标停顿时间合理地回收若干个小区间，而不是整个堆空间，从而减少gc停顿时间。

3. Java 中的四种引用

强引用：通过new出来的引用，只要强引用还存在，则不会回收。
软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。
弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。
虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。

4. 类加载机制？

加载--连接(准备、验证、解析3个部分统称为连接)--初始化--使用--卸载，使用双亲委派模式进行类的加载，loadClass 方法加载一个类后进行判断，判断是否已经加载，如果没有加载则遵循双亲
委派模式，寻找父类加载器递归查找，直到找到 BootStrap 类加载器。最后根据找到的类，是否需要解析。

5. 垃圾回收机制？

引用计数和跟搜索法，根搜索法主要从虚拟机栈（栈幁中的本地变量表）中引用的对象，方法区中类静态引用的对象，方法区中常量引用的对象，本地方法中 JNI 引用的对象。

6. 堆存放的东西？

堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。

