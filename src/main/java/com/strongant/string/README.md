1. 下面程序的运行结果是？

```java
String str1 = "Hello";
String str2 = "he" + new String("llo");
System.err.println(str1 == str2);
```

答案： false
原因：

> 链接：https://www.nowcoder.net/questionTerminal/17068b08ab1c4c50a012397ec9a272a6?toCommentId=421749
来源：牛客网
    1) String 类是 final 类，也即意味着 String 类不能被继承，并且它的成员方法都默认为 final 方法。在 Java 中，被 final 修饰的类是不允许被继承的，
    并且该类中的成员方法都默认为 final 方法。
 
    2）String 类底层是 char 数组来保存字符串的。
 
    对 String 对象的任何改变都不影响到原对象，相关的任何 change 操作都会生成新的对象
 
    字符串常量池
 
 
    在 class 文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做 class 文件常量池，在运行期间对应着方法区的运行时常量池。
 
    JVM 为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池
 
    工作原理
 
    当代码中出现字面量形式创建字符串对象时，JVM 首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，
    否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。
 
    实现前提
 
    字符串常量池实现的前提条件就是 Java 中 String 对象是不可变的，这样可以安全保证多个变量共享同一个对象。如果 Java 中的 String 对象可变的话，
    一个引用操作改变了对象的值，那么其他的变量也会受到影响，显然这样是不合理的。
 
 
 
    String str1 = "hello";
 
    这里的 str1 指的是方法区中的字符串常量池中的 “hello”，编译时期就知道的； 
 
    String str2 = "he" + new String("llo");
 
    这里的 str2 必须在运行时才知道 str2 是什么，所以它是指向的是堆里定义的字符串 “hello” ，所以这两个引用是不一样的。
 
    如果用 str1.equal(str2)，那么返回的是true；因为 String 类重写了 equals() 方法。
 
    编译器没那么智能,它不知道 "he" + new String("llo") 的内容是什么,所以才不敢贸然把 "hello" 这个对象的引用赋给 str2.
 
    如果语句改为:"he"+"llo"这样就是true了。
 
    new String("zz") 实际上创建了2个 String 对象，就是使用“zz”通过双引号创建的（在字符串常量池），另一个是通过new创建的（在堆里）。只不过他们的创建的时期不同，一个是编译期，一个是运行期。
 
    String s = "a"+"b"+"c";
 
    语句中，“a”,"b", "c"都是常量，编译时就直接存储他们的字面值，而不是他们的引用，在编译时就直接将它们连接的结果提取出来变成"abc"了。